# String,StringBuffer,StringBuilder

## String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？

1. String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String 也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。
2. StringBuffer是线程安全的。
3. StringBuilder是非线程安全的。

## String 

看下源码:
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    ...
}
```

可以看到String是final的,不允许继承.里面用来存储value的是一个final数组,也是不允许修改的.

## AbstractStringBuilder
> StringBuffer和StringBuilder都是都是继承了AbstractStringBuilder.

在这里面真实的保存了数据内容,数据内容其实是一个`char[] value;`数组,在其构造方法中其实就是初始化该字符数组.
```java
char[] value;
AbstractStringBuilder() {
}
AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
```

### 扩容
既然数据内容(上面的value数组)是在AbstractStringBuilder里面的,那么很多操作我觉得应该也是在父类里面,比如扩容,下面我们看看源码

```java
public void ensureCapacity(int minimumCapacity) {
    if (minimumCapacity > 0)
        ensureCapacityInternal(minimumCapacity);
}

/**
* 确保value字符数组不会越界.重新new一个数组,引用指向value
*/    
private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length > 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}

/**
* 扩容:之前的大小的2倍+2
*/    
private int newCapacity(int minCapacity) {
    // overflow-conscious code   扩大2倍+2
    //小知识点:这里可能会溢出,溢出后是负数哈,注意
    int newCapacity = (value.length << 1) + 2;
    if (newCapacity - minCapacity < 0) {
        newCapacity = minCapacity;
    }
    //MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8,先判断一下预期容量(newCapacity)是否在0<x<MAX_ARRAY_SIZE之间,在这区间内就直接将数值返回,不在这区间就去判断一下是否溢出
    return (newCapacity <= 0 || MAX_ARRAY_SIZE - newCapacity < 0)
        ? hugeCapacity(minCapacity)
        : newCapacity;
}

/**
* 判断大小  是否溢出
*/
private int hugeCapacity(int minCapacity) {
    if (Integer.MAX_VALUE - minCapacity < 0) { // overflow
        throw new OutOfMemoryError();
    }
    return (minCapacity > MAX_ARRAY_SIZE)
        ? minCapacity : MAX_ARRAY_SIZE;
}
```
可以看到这里的扩容方式是 = 以前的大小*2+2,其他的细节方法中已给出详细注释.

### 增加

举一个比较有代表性的添加,详细注释在代码中

```java
/**
* 追加:从指定字符串的片段
*/
public AbstractStringBuilder append(CharSequence s, int start, int end) {
    //1. 如果是空,则添加字符串"null"
    if (s == null)
        s = "null";
    //2. 判断是否越界
    if ((start < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException(
            "start " + start + ", end " + end + ", s.length() "
            + s.length());
    //3. 记录添加字符串长度
    int len = end - start;
    //4. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(还有复制原内容到新数组中)
    ensureCapacityInternal(count + len);
    //5. 追加内容到value数组最后
    for (int i = start, j = count; i < end; i++, j++)
        value[j] = s.charAt(i);
    //6. 更新数组长度
    count += len;
    return this;
}
```

### 删除
### 改
### 查询

## StringBuffer

先看看类的继承结构

![](http://olg7c0d2n.bkt.clouddn.com/18-4-17/57996290.jpg)

定义

```java
public final class StringBuffer
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```

StringBuffer和StringBuilder都是相同的继承结构.都是继承了AbstractStringBuilder.

StringBuffer和StringBuilder构造方法,可以看到默认大小是16,
```java
    public StringBuffer() {
        super(16);
    }
    public StringBuffer(int capacity) {
        super(capacity);
    }
```

我们先来看看StringBuffer的append方法

## StringBuilder

定义
```java
public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```
