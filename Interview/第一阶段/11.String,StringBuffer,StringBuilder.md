# 一文彻底搞懂String,StringBuffer,StringBuilder

> 第一次写此类型文章,由于本人才疏学浅,有很多地方可能存在误解和不足,还望大家在评论区批评指正.

## 一.String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？

1. String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String 也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。
2. StringBuffer是线程安全的。
3. StringBuilder是非线程安全的。

## 二.String源码分析

看下源码:
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    ...
}
```

可以看到String是final的,不允许继承.里面用来存储value的是一个final数组,也是不允许修改的.String有很多方法,下面就String类常用方法进行分析.

### 1.构造方法

```java
public String() {
    this.value = "".value;
}
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
public String(char value[]) {
    this.value = Arrays.copyOf(value, value.length);
}
...
```
可以看到默认的构造器是构建的空字符串,其实所有的构造器就是给value数组赋初值.

### 2.字符串长度
返回该字符串的长度,这太简单了,就是返回value数组的长度.
```java
public int length() {
    return value.length;
}
```
### 3.字符串某一位置字符
返回字符串中指定位置的字符；
```java
public char charAt(int index) {
    //1. 首先判断是否越界
    if ((index < 0) || (index >= value.length)) {
        throw new StringIndexOutOfBoundsException(index);
    }
    //2. 返回相应位置的值
    return value[index];
}
```
### 4.提取子串

用String类的substring方法可以提取字符串中的子串，简单分析一下substring(int beginIndex, int endIndex)吧,该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个 **新的字符串(重新new了一个String)** 返回。

```java
public String substring(int beginIndex, int endIndex) {
    //1.验证入参是否越界
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex > value.length) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    //2. 记录切割长度
    int subLen = endIndex - beginIndex;
    //3. 入参合法性
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    //4. 如果开始切割处是0,结束切割处是value数组长度,那么相当于没有切割嘛,就直接返回原字符串;如果是其他情况:则重新新建一个String对象
    return ((beginIndex == 0) && (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}

/**
* 通过一个char数组生成String对象,从offset到offset+count处.
*/
public String(char value[], int offset, int count) {
    if (offset < 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count <= 0) {
        if (count < 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset <= value.length) {
            this.value = "".value;
            return;
        }
    }
    // Note: offset or count might be near -1>>>1.
    if (offset > value.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }
    this.value = Arrays.copyOfRange(value, offset, offset+count);
}

```

```java
String str1 = new String("asdfzxc");
2 String str2 = str1.substring(2);//str2 = "dfzxc"
3 String str3 = str1.substring(2,5);//str3 = "dfz"
```
### 5.字符串比较
1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。
2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。
3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。
4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。
```java
String str1 = new String("abc");
2 String str2 = new String("ABC");
3 int a = str1.compareTo(str2);//a>0
4 int b = str1.compareTo(str2);//b=0
5 boolean c = str1.equals(str2);//c=false
6 boolean d = str1.equalsIgnoreCase(str2);//d=true
```
### 6.字符串连接
public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于"+"。
### 7.字符串中单个字符查找
1)public int indexOf(int ch/String str)//用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。
2)public int indexOf(int ch/String str, int fromIndex)//改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。
3)public int lastIndexOf(int ch/String str)//该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。
4)public int lastIndexOf(int ch/String str, int fromIndex)//该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。
### 8.字符串中字符的大小写转换
public String toLowerCase()//返回将当前字符串中所有字符转换成小写后的新串
2)public String toUpperCase()//返回将当前字符串中所有字符转换成大写后的新串
### 9.字符串中字符的替换
1)public String replace(char oldChar, char newChar)//用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。
2)public String replaceFirst(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。
3)public String replaceAll(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。
### 10.其他类方法
1)String trim()//截去字符串两端的空格，但对于中间的空格不处理
2)boolean statWith(String prefix)或boolean endWith(String suffix)//用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。
3)regionMatches(boolean b, int firstStart, String other, int otherStart, int length)//从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。
4)contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。
5)String[] split(String str)//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。
### 11.字符串与基本类型的转换

1、字符串转换为基本类型
java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：
1)public static byte parseByte(String s)
2)public static short parseShort(String s)
3)public static short parseInt(String s)
4)public static long parseLong(String s)
5)public static float parseFloat(String s)
6)public static double parseDouble(String s)

2、基本类型转换为字符串类型
String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。
1)static String valueOf(char data[])
2)static String valueOf(char data[], int offset, int count)
3)static String valueOf(boolean b)
4)static String valueOf(char c)
5)static String valueOf(int i)
6)static String valueOf(long l)
7)static String valueOf(float f)
8)static String valueOf(double d)

3、进制转换
使用Long类中的方法得到整数之间的各种进制转换的方法：
Long.toBinaryString(long l)
Long.toOctalString(long l)
Long.toHexString(long l)
Long.toString(long l, int p)//p作为任意进制

**注意:Android 6.0（23） 源码中，String类的实现被替换了，具体调用的时候，会调用一个StringFactory来生成一个String.**
来看下Android源码中String,,我擦,,这.....直接抛错误`UnsupportedOperationException`,可能是因为oracle告Google的原因吧..
```java
public String() {
    throw new UnsupportedOperationException("Use StringFactory instead.");
}
public String(String original) {
    throw new UnsupportedOperationException("Use StringFactory instead.");
}
```

我们平时开发APP时都是使用的java.lang包下面的String,上面的问题一般不会遇到,但是作为Android开发者还是要了解一下.

## 三.AbstractStringBuilder源码分析

先看看类的继承结构

![](http://olg7c0d2n.bkt.clouddn.com/18-4-17/57996290.jpg)

> 可以看到StringBuffer和StringBuilder都是继承了AbstractStringBuilder.所以这里先分析一下AbstractStringBuilder.

在这基类里面真实的保存了StringBuffer和StringBuilder操作的实际数据内容,数据内容其实是一个`char[] value;`数组,在其构造方法中其实就是初始化该字符数组.
```java
char[] value;
AbstractStringBuilder() {
}
AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
```

### 1.扩容
既然数据内容(上面的value数组)是在AbstractStringBuilder里面的,那么很多操作我觉得应该也是在父类里面,比如扩容,下面我们看看源码

```java
public void ensureCapacity(int minimumCapacity) {
    if (minimumCapacity > 0)
        ensureCapacityInternal(minimumCapacity);
}

/**
* 确保value字符数组不会越界.重新new一个数组,引用指向value
*/    
private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length > 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}

/**
* 扩容:之前的大小的2倍+2
*/    
private int newCapacity(int minCapacity) {
    // overflow-conscious code   扩大2倍+2
    //小知识点:这里可能会溢出,溢出后是负数哈,注意
    int newCapacity = (value.length << 1) + 2;
    if (newCapacity - minCapacity < 0) {
        newCapacity = minCapacity;
    }
    //MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8,先判断一下预期容量(newCapacity)是否在0<x<MAX_ARRAY_SIZE之间,在这区间内就直接将数值返回,不在这区间就去判断一下是否溢出
    return (newCapacity <= 0 || MAX_ARRAY_SIZE - newCapacity < 0)
        ? hugeCapacity(minCapacity)
        : newCapacity;
}

/**
* 判断大小  是否溢出
*/
private int hugeCapacity(int minCapacity) {
    if (Integer.MAX_VALUE - minCapacity < 0) { // overflow
        throw new OutOfMemoryError();
    }
    return (minCapacity > MAX_ARRAY_SIZE)
        ? minCapacity : MAX_ARRAY_SIZE;
}
```
可以看到这里的扩容方式是 = 以前的大小*2+2,其他的细节方法中已给出详细注释.

### 2.追加

举一个比较有代表性的添加,详细注释在代码中

```java
/**
* 追加:从指定字符串的片段
*/
public AbstractStringBuilder append(CharSequence s, int start, int end) {
    //1. 如果是空,则添加字符串"null"
    if (s == null)
        s = "null";
    //2. 判断是否越界
    if ((start < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException(
            "start " + start + ", end " + end + ", s.length() "
            + s.length());
    //3. 记录添加字符串长度
    int len = end - start;
    //4. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(扩容时还有复制原内容到新数组中)
    ensureCapacityInternal(count + len);
    //5. 追加内容到value数组最后
    for (int i = start, j = count; i < end; i++, j++)
        value[j] = s.charAt(i);
    //6. 更新数组长度
    count += len;
    return this;
}
```

### 3.增加

这里的大体思想是和以前大一的时候用C语言在数组中插入数据是一样的.

这里假设需要插入的字符串s,插入在目标字符串desOffset处,插入的长度是len.首先将需要插入处的desOffset~desOffset+len往后挪,挪到desOffset+len处,然后在desOffset处插入目标字符串.

大体思想就是这样,是不是觉得很熟悉?? `ヽ(￣▽￣)ﾉ`

下面这个方法是上面思路的具体实现,详细的逻辑分析已经放到代码注释中.

```java
//插入字符串,从dstOffset索引处开始插入,插入内容为s中的[start,end]字符串
public AbstractStringBuilder insert(int dstOffset, CharSequence s,
                                         int start, int end) {
    //1. 空处理
    if (s == null)
        s = "null";
    //2. 越界判断
    if ((dstOffset < 0) || (dstOffset > this.length()))
        throw new IndexOutOfBoundsException("dstOffset "+dstOffset);
    //3. 入参检测是否合法
    if ((start < 0) || (end < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException(
            "start " + start + ", end " + end + ", s.length() "
            + s.length());
    //4. 长度记录
    int len = end - start;
    //5. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(扩容时还有复制原内容到新数组中)
    ensureCapacityInternal(count + len);
    //6. 将原数组中dstOffset开始的count - dstOffset个字符复制到dstOffset + len处,,,,这里其实就是腾出一个len长度的区间,用用户存放目标字符串,这个区间就是dstOffset到dstOffset + len
    System.arraycopy(value, dstOffset, value, dstOffset + len,
                     count - dstOffset);
    //7. 存放目标字符串
    for (int i=start; i<end; i++)
        value[dstOffset++] = s.charAt(i);
    //8. 记录字符串长度
    count += len;
    //9. 返回自身引用  方便链式调用
    return this;
}
```

### 4.删除

源码里面的删除操作实际上是复制,比如下面这个方法删除start到end之间的字符,实际是将以end开始的字符复制到start处,**并且将数组的长度记录count减去len个**

```java
//删除从start到end索引区间( [start,end)前闭后开区间 )内内容
public AbstractStringBuilder delete(int start, int end) {
    if (start < 0)
        throw new StringIndexOutOfBoundsException(start);
    if (end > count)
        end = count;
    if (start > end)
        throw new StringIndexOutOfBoundsException();
    int len = end - start;
    //当start==end时不会改变
    if (len > 0) {
      //将value数组的start+len位置开始的count-end个字符复制到value数组的start位置处.  注意,并且将数组count减去len个.
        System.arraycopy(value, start+len, value, start, count-end);
        count -= len;
    }
    return this;
}
```

### 5.切割

我擦,,,,原来StringBuffer的切割效率并不高嘛,其实就是new了一个String....

```java
public String substring(int start, int end) {
    if (start < 0)
        throw new StringIndexOutOfBoundsException(start);
    if (end > count)
        throw new StringIndexOutOfBoundsException(end);
    if (start > end)
        throw new StringIndexOutOfBoundsException(end - start);
    return new String(value, start, end - start);
}
```

### 6.改

改其实就是对其替换,而在源码中替换最终的实现其实是复制(还是复制..`(￣▽￣)~*`).

大体思路: 假设需要将字符串str替换value数组中的start-end中,这时只需将end后面的字符往后移动,在中间腾出一个坑,用于存放需要替换的str字符串.最后将str放到value数组中start索引处.

```java
public AbstractStringBuilder replace(int start, int end, String str) {
    //1. 入参检测合法性
    if (start < 0)
        throw new StringIndexOutOfBoundsException(start);
    if (start > count)
        throw new StringIndexOutOfBoundsException("start > length()");
    if (start > end)
        throw new StringIndexOutOfBoundsException("start > end");
    if (end > count)
        end = count;
    //2. 目标String长度
    int len = str.length();
    //3. 计算新的数组的长度
    int newCount = count + len - (end - start);
    //4. 判断一下是否需要扩容
    ensureCapacityInternal(newCount);

    //5. 将value数组的end位置开始的count - end个字符复制到value数组的start+len处. 相当于把end之后的字符移到最后去,然后中间留个坑,用来存放str(需要替换成的值)
    System.arraycopy(value, end, value, start + len, count - end);
    //6. 这是String的一个方法,用于将str复制到value中start处  其最底层实现是native方法(getCharsNoCheck() )
    str.getChars(value, start);
    //7. 更新count
    count = newCount;
    return this;
}
```

### 7.查询

查询是最简单的,就是返回数组中相应索引处的值.

```java
public char charAt(int index) {
    if ((index < 0) || (index >= count))
        throw new StringIndexOutOfBoundsException(index);
    return value[index];
}
```

## 四.StringBuffer源码分析

定义

```java
public final class StringBuffer
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```

StringBuffer和StringBuilder都是相同的继承结构.都是继承了AbstractStringBuilder.

StringBuffer和StringBuilder构造方法,可以看到默认大小是16,
```java
public StringBuffer() {
    super(16);
}
public StringBuffer(int capacity) {
    super(capacity);
}
```

我们先来看看StringBuffer的append方法

## 五.StringBuilder分析

定义
```java
public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```
