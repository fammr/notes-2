# 一文彻底搞懂String,StringBuffer,StringBuilder

> 第一次写此类型文章,由于本人才疏学浅,有很多地方可能存在误解和不足,还望大家在评论区批评指正.

## 一.String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？

1. String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String 也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。
2. StringBuffer是线程安全的。
3. StringBuilder是非线程安全的。

## 二.String 

看下源码:
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    ...
}
```

可以看到String是final的,不允许继承.里面用来存储value的是一个final数组,也是不允许修改的.

## 三.AbstractStringBuilder
> StringBuffer和StringBuilder都是继承了AbstractStringBuilder.

在这基类里面真实的保存了StringBuffer和StringBuilder操作的实际数据内容,数据内容其实是一个`char[] value;`数组,在其构造方法中其实就是初始化该字符数组.
```java
char[] value;
AbstractStringBuilder() {
}
AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
```

### 1.扩容
既然数据内容(上面的value数组)是在AbstractStringBuilder里面的,那么很多操作我觉得应该也是在父类里面,比如扩容,下面我们看看源码

```java
public void ensureCapacity(int minimumCapacity) {
    if (minimumCapacity > 0)
        ensureCapacityInternal(minimumCapacity);
}

/**
* 确保value字符数组不会越界.重新new一个数组,引用指向value
*/    
private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length > 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}

/**
* 扩容:之前的大小的2倍+2
*/    
private int newCapacity(int minCapacity) {
    // overflow-conscious code   扩大2倍+2
    //小知识点:这里可能会溢出,溢出后是负数哈,注意
    int newCapacity = (value.length << 1) + 2;
    if (newCapacity - minCapacity < 0) {
        newCapacity = minCapacity;
    }
    //MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8,先判断一下预期容量(newCapacity)是否在0<x<MAX_ARRAY_SIZE之间,在这区间内就直接将数值返回,不在这区间就去判断一下是否溢出
    return (newCapacity <= 0 || MAX_ARRAY_SIZE - newCapacity < 0)
        ? hugeCapacity(minCapacity)
        : newCapacity;
}

/**
* 判断大小  是否溢出
*/
private int hugeCapacity(int minCapacity) {
    if (Integer.MAX_VALUE - minCapacity < 0) { // overflow
        throw new OutOfMemoryError();
    }
    return (minCapacity > MAX_ARRAY_SIZE)
        ? minCapacity : MAX_ARRAY_SIZE;
}
```
可以看到这里的扩容方式是 = 以前的大小*2+2,其他的细节方法中已给出详细注释.

### 2.追加

举一个比较有代表性的添加,详细注释在代码中

```java
/**
* 追加:从指定字符串的片段
*/
public AbstractStringBuilder append(CharSequence s, int start, int end) {
    //1. 如果是空,则添加字符串"null"
    if (s == null)
        s = "null";
    //2. 判断是否越界
    if ((start < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException(
            "start " + start + ", end " + end + ", s.length() "
            + s.length());
    //3. 记录添加字符串长度
    int len = end - start;
    //4. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(扩容时还有复制原内容到新数组中)
    ensureCapacityInternal(count + len);
    //5. 追加内容到value数组最后
    for (int i = start, j = count; i < end; i++, j++)
        value[j] = s.charAt(i);
    //6. 更新数组长度
    count += len;
    return this;
}
```

### 3.增加

这里的大体思想是和以前大一的时候用C语言在数组中插入数据是一样的.

这里假设需要插入的字符串s,插入在目标字符串desOffset处,插入的长度是len.首先将需要插入处的desOffset~desOffset+len往后挪,挪到desOffset+len处,然后在desOffset处插入目标字符串.

大体思想就是这样,是不是觉得很熟悉?? `ヽ(￣▽￣)ﾉ`

下面这个方法是上面思路的具体实现,详细的逻辑分析已经放到代码注释中.

```java
//插入字符串,从dstOffset索引处开始插入,插入内容为s中的[start,end]字符串
public AbstractStringBuilder insert(int dstOffset, CharSequence s,
                                         int start, int end) {
    //1. 空处理
    if (s == null)
        s = "null";
    //2. 越界判断
    if ((dstOffset < 0) || (dstOffset > this.length()))
        throw new IndexOutOfBoundsException("dstOffset "+dstOffset);
    //3. 入参检测是否合法
    if ((start < 0) || (end < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException(
            "start " + start + ", end " + end + ", s.length() "
            + s.length());
    //4. 长度记录
    int len = end - start;
    //5. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(扩容时还有复制原内容到新数组中)
    ensureCapacityInternal(count + len);
    //6. 将原数组中dstOffset开始的count - dstOffset个字符复制到dstOffset + len处,,,,这里其实就是腾出一个len长度的区间,用用户存放目标字符串,这个区间就是dstOffset到dstOffset + len
    System.arraycopy(value, dstOffset, value, dstOffset + len,
                     count - dstOffset);
    //7. 存放目标字符串
    for (int i=start; i<end; i++)
        value[dstOffset++] = s.charAt(i);
    //8. 记录字符串长度
    count += len;
    //9. 返回自身引用  方便链式调用
    return this;
}
```

### 4.删除

源码里面的删除操作实际上是复制,比如下面这个方法删除start到end之间的字符,实际是将以end开始的字符复制到start处,**并且将数组的长度记录count减去len个**

```java
//删除从start到end索引区间( [start,end)前闭后开区间 )内内容
public AbstractStringBuilder delete(int start, int end) {
    if (start < 0)
        throw new StringIndexOutOfBoundsException(start);
    if (end > count)
        end = count;
    if (start > end)
        throw new StringIndexOutOfBoundsException();
    int len = end - start;
    //当start==end时不会改变
    if (len > 0) {
      //将value数组的start+len位置开始的count-end个字符复制到value数组的start位置处.  注意,并且将数组count减去len个.
        System.arraycopy(value, start+len, value, start, count-end);
        count -= len;
    }
    return this;
}
```

### 5.切割

我擦,,,,原来StringBuffer的切割效率并不高嘛,其实就是new了一个String....

```java
public String substring(int start, int end) {
    if (start < 0)
        throw new StringIndexOutOfBoundsException(start);
    if (end > count)
        throw new StringIndexOutOfBoundsException(end);
    if (start > end)
        throw new StringIndexOutOfBoundsException(end - start);
    return new String(value, start, end - start);
}
```

### 6.改
### 7.查询

## 四.StringBuffer

先看看类的继承结构

![](http://olg7c0d2n.bkt.clouddn.com/18-4-17/57996290.jpg)

定义

```java
public final class StringBuffer
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```

StringBuffer和StringBuilder都是相同的继承结构.都是继承了AbstractStringBuilder.

StringBuffer和StringBuilder构造方法,可以看到默认大小是16,
```java
public StringBuffer() {
    super(16);
}
public StringBuffer(int capacity) {
    super(capacity);
}
```

我们先来看看StringBuffer的append方法

## 五.StringBuilder

定义
```java
public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
```
