# include <iostream>

using namespace std;

/*
2017年3月19日18:43:39

插入排序

时间复杂度 O(n^2)

直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，
按其关键字大小插入到前面已经排好序的子序列中的适当位置，
直到全部记录插入完成为止。 
 
 
 设数组为a[0…n-1]。

1.      初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1

2.      将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。

3.      i++并重复第二步直到i==n-1。排序完成。
 
*/ 


/*
直接插入排序
直接插入排序是稳定的，不会改变相同元素的相对顺序。 
*/ 
void Insertsort2(int a[], int n)  
{
	/*
	即每次a[i]先和前面一个数据a[i-1]比较，如果a[i] > a[i-1]说明a[0…i]也是有序的，
	无须调整。否则就令j=i-1,temp=a[i]。然后一边将数据a[j]向后移动一边向前搜索，
	当有数据a[j]<a[i]时停止并将temp放到a[j + 1]处。
	*/
	int i,j,temp;
	for(int i=0; i<n; i++)
	{
		if(a[i] < a[i-1])   //从第1个元素开始,如果后一个元素比前一个元素小 
		{
			temp = a[i];
			for(j = i-1; j>=0 && temp<a[j]; j--)  //从当前位置往前移,找到相应的位置 
			{
				a[j+1] = a[j];   //将前面的元素往后移动 
			}
			a[j+1] = temp;   //将temp放到合适位置 
		}
	} 
} 

/*
  二分查找插入排序：
  因为在一个有序区中查找一个插入位置，
  所以可使用二分查找，减少元素比较次数提高效率
  
  具体如下（实现为升序）：
设数组为a[0…n]。
1.        将原序列分成有序区和无序区。a[0…i-1]为有序区，a[i…n] 为无序区。
（i从1开始）
2.        从无序区中取出第一个元素，即a[i]，使
用二分查找算法在有序区中查找要插入的位置索引j。
3.        将a[j]到a[i-1]的元素后移，并将a[i]赋值给a[j]。
4.        重复步骤2~3，直到无序区元素为0。
*/ 

int main(void)
{
	int number[8] = {95, 45, 15, 78, 84, 51, 24, 12};
	Insertsort2(number,8);
	for(int i=0; i<8; i++)
	{
		cout<<number[i]<<" ";
	}
    return 0;
}

