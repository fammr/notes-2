# 进程与线程


## 1. 进程的三种基本状态

- 就绪(Ready)状态
- 执行(Running)状态
- 阻塞(Block)状态

## 2. PCB

在OS的核心为每个进程专门定义了一个数据结构--进程控制块PCB.

## 3.进程的创建

1. 申请空白PCB,为新进程申请获取唯一的数字标识符,并从PCB集合中索取一个空白PCB.
2. 为新进程分配其运行所需的资源,包括各种物理和逻辑资源,入内存,文件,I/O设备和CPU时间等.
3. 初始化进程控制块(PCB).
4. 如果进程就绪队列能够接纳新进程,便将新进场插入就绪队列.

## 4.临界资源（Critical Resource）

> 许多硬件资源如打印机,磁带机等,都属于临界资源,诸进程应才去互斥方式,实现对这种资源的共享.

不论是硬件临界资源还是软件临界资源,多个进程必须互斥地对它进行访问.人们把每个进程中访问临界资源的那段代码称为临界区.

可以把访问临界资源的循环进程描述如下:

	while(TRUE){
		进入区
		临界区
		退出区
		剩余区
	}

### 4.1 硬件同步机制

1. 关中断

	关中断是实现进程互斥最简单的方式之一.
2. 利用Test-and-Set指令实现互斥

	这是一种借助一条硬件指令---"测试并建立"指令TS(Test-and-Set)以实现互斥的方法.
3. 利用Swap指令实现进程互斥

	该指令称为对换指令,在Intel 80*86 中又称为XCHG指令,用于交换两个字的内容.

### 4.2 信号量机制

> 1965年,荷兰科学家Dijkstra提出的信号量(Semaphores)机制是一种卓有成效的进程同步工具.

1.整型信号量

P操作

	wait(S){
		while(S<=0);
		S--;
	}

V操作

	signal(S){
		S++;
	}

2.记录型信号量

3.AND型信号量

4.信号量集

## 5. 死锁

### 5.1 死锁的定义

在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统 的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

**死锁产生的必要条件**

1. **互斥条件**：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

2. **请求和保持条件**：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

3. **不剥夺条件**：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

4. **环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

### 5.2 死锁的处理策略

- 预防死锁

设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁。

- 避免死锁

在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。

- 死锁的检测及解除

无需釆取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时 地检测出死锁的发生，然后釆取某种措施解除死锁。

**银行家算法**

银行家算法是最著名的死锁避免算法。它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。


## 6.管程机制

> 虽然信号量机制是一种即方便,又有效的进程同步机制,但每个要访问临界资源的进程都必须自备同步操作wait和signal.这就使大量的同步操作分散在各个进程中.这不仅给系统的管理带来了麻烦,而且还会因同步操作的使用不当导致系统死锁.这样,在解决上述问题的过程中,便产生了一种新的进程同步工具---管层.

## 7.经典进程同步问题

### 7.1生产者-消费者问题

**问题描述**

一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。

**问题分析**

1) 关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。

2) 整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。

3) 信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。

生产者-消费者进程的描述如下：

	semaphore mutex=1; //临界区互斥信号量
	semaphore empty=n;  //空闲缓冲区
	semaphore full=0;  //缓冲区初始化为空
	producer () { //生产者进程
	    while(1){
	        produce an item in nextp;  //生产数据
	        P(empty);  //获取空缓冲区单元
	        P(mutex);  //进入临界区.
	        add nextp to buffer;  //将数据放入缓冲区
	        V(mutex);  //离开临界区,释放互斥信号量
	        V(full);  //满缓冲区数加1
	    }
	}
	consumer () {  //消费者进程
	    while(1){
	        P(full);  //获取满缓冲区单元
	        P(mutex);  // 进入临界区
	        remove an item from buffer;  //从缓冲区中取出数据
	        V (mutex);  //离开临界区，释放互斥信号量
	        V (empty) ;  //空缓冲区数加1
	        consume the item;  //消费数据
	    }
	}

### 7.2 读者-写者问题

**问题描述**

有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。

**问题分析**

1) 关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。

2) 整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。

3) 信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。

	int count=0;  //用于记录当前的读者数量
	semaphore mutex=1;  //用于保护更新count变量时的互斥
	semaphore rw=1;  //用于保证读者和写者互斥地访问文件
	writer () {  //写者进程
	    while (1){
	        P(rw); // 互斥访问共享文件
	        Writing;  //写入
	        V(rw) ;  //释放共享文件
	    }
	}
	
	reader () {  // 读者进程
	    while(1){
	        P (mutex) ;  //互斥访问count变量
	        if (count==0)  //当第一个读进程读共享文件时
	            P(rw);  //阻止写进程写
	        count++;  //读者计数器加1
	        V (mutex) ;  //释放互斥变量count
	        reading;  //读取
	        P (mutex) ;  //互斥访问count变量
	        count--; //读者计数器减1
	        if (count==0)  //当最后一个读进程读完共享文件
	            V(rw) ;  //允许写进程写
	        V (mutex) ;  //释放互斥变量 count
	    }
	}

### 7.3 哲学家进餐问题

**问题描述**

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

**问题分析**

1) 关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。

2) 整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。

3) 信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {l, 1, 1, 1, 1}用于对5个筷子的互斥访问。

对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。

	semaphore chopstick[5] = {1,1,1,1,1}; //初始化信号量
	semaphore mutex=l;  //设置取筷子的信号量
	Pi(){ //i号哲学家的进程
	    do{
	        P (mutex) ; //在取筷子前获得互斥量
	        P (chopstick [i]) ; //取左边筷子
	        P (chopstick[ (i+1) %5]) ;  //取右边筷子
	        V (mutex) ; //释放取筷子的信号量
	        eat;  //进餐
	        V(chopstick[i] ) ;  //放回左边筷子
	        V(chopstick[ (i+l)%5]) ;  //放回右边筷子
	        think;  // 思考
	    }while(1);
	}

## 8. 进程与程序的区别与联系

- 进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序，离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块(PCB)三部分组成的。而程序是一组有序的指令集合，是一种静态的概念。

- 进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命周期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。

- 一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。

- 进程与程序的组成不同。进程的组成包括程序、数据和PCB。